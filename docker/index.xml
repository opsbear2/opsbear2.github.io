<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Welcome to Bear2&#39;s Secret Garden 💬🐻💬</title>
    <link>https://opsbear2.com/docker/</link>
    <description>Recent content in Docker on Welcome to Bear2&#39;s Secret Garden 💬🐻💬</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 03 Aug 2022 15:56:45 +0800</lastBuildDate><atom:link href="https://opsbear2.com/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2.容器的本质</title>
      <link>https://opsbear2.com/docker/2.containerconcept/</link>
      <pubDate>Wed, 03 Aug 2022 15:56:45 +0800</pubDate>
      
      <guid>https://opsbear2.com/docker/2.containerconcept/</guid>
      <description>1 什么是容器 2 容器的隔离性  2.1 为什么要隔离 2.2 与虚拟机的区别   3 隔离实现原理      1 什么是容器     从字面上来看，容器就是 Container，一般把它形象地比喻成现实世界里的集装箱，它也正好和 Docker 的现实含义相对应，因为码头工人（那只可爱的小鲸鱼）就是不停地在搬运集装箱
集装箱的作用是标准化封装各种货物，一旦打包完成之后，就可以从一个地方迁移到任意的其他地方。相比散装形式而言，集装箱隔离了箱内箱外两个世界，保持了货物的原始形态，避免了内外部相互干扰，极大地简化了商品的存储、运输、管理等工作
再回到我们的计算机世界，容器也发挥着同样的作用，不过它封装的货物是运行中的应用程序，也就是进程，同样它也会把进程与外界隔离开，让进程与外部系统互不影响
实际看一下在容器里运行的进程
使用 docker pull 命令，拉取一个新的镜像——操作系统 Alpine
$ docker pull alpine 使用 docker run 命令运行它的 Shell 程序
$ docker run -it alpine sh	# -it参数，临时离开当前操作系统，进入容器内部 在容器里查看系统信息，会发现已经不再是外面的 Centos 系统了，而是变成了 Alpine Linux 3.15，使用 ps 命令也只会看到一个完全“干净”的运行环境，除了 Shell（即 sh）没有其他的进程存在，也就是说，在容器内部是一个全新的 Alpine 操作系统，在这里运行的应用程序完全看不到外面的 Ubuntu 系统，两个系统被互相“隔离”了，就像是一个“世外桃源”</description>
    </item>
    
    <item>
      <title>1.初识容器</title>
      <link>https://opsbear2.com/docker/1.beginning/</link>
      <pubDate>Fri, 29 Jul 2022 10:39:27 +0800</pubDate>
      
      <guid>https://opsbear2.com/docker/1.beginning/</guid>
      <description>1 初始容器 2 Docker的安装  2.1 手动安装 2.2 自动安装 2.3 卸载docker   3 Docker的简单使用 4 Docker的架构      1 初始容器     在学习Kubernetes之前，先从最简单、最基本的知识入手，聊聊最流行的容器技术 Docker
Docker的形态
目前使用 Docker 基本上有两个选择：Docker Desktop 和 Docker Engine
Docker Desktop 是专门针对个人使用而设计的，支持 Mac 和 Windows 快速安装，具有直观的图形界面，还集成了许多周边工具，方便易用，但是太推荐使用 Docker Desktop，原因有两个。第一个，它是商业产品，难免会带有 Docker 公司的“私人气息”，有一些自己的、非通用的东西，不利于我们后续的 Kubernetes 学习。第二个，它只是对个人学习免费，受条款限制不能商用，我们在日常工作中难免会“踩到雷区”
Docker Engine 则和 Docker Desktop 正好相反，完全免费，但只能在 Linux 上运行，只能使用命令行操作，缺乏辅助工具，需要我们自己动手 DIY 运行环境。不过要是较起真来，它才是 Docker 当初的真正形态，“血脉”最纯正，也是现在各个公司在生产环境中实际使用的 Docker 产品，毕竟机房里 99% 的服务器跑的都是 Linux</description>
    </item>
    
  </channel>
</rss>
