[{"id":0,"href":"/mydocs/blog/4.sitemap/","title":"4.收录你的网站","parent":"搭建博客","content":"   1 什么是Sitemap 2 收录网站      1 什么是Sitemap     在博客上发布文章之后，怎么从搜索引擎找到他们呢？\n Sitemap的定义\n Sitemap，站点地图是一种文件，您可以在其中提供与您网站中的网页、视频或其他文件有关的信息，还可以说明这些内容之间的关系。Google 等搜索引擎会读取此文件，以便更高效地抓取您的网站。站点地图会告诉 Google 您认为网站中的哪些网页和文件比较重要，还会提供与这些文件有关的重要信息。例如，网页上次更新的时间和网页是否有任何备用的语言版本\n简而言之，Sitemap 可以将网站内容的组织结构提交给搜索引擎，告知你的网站上有哪些可供抓取的网页，从而提高网站的曝光率\n2 收录网站     Hugo 构建静态页后会生成Sitemap文件，路径为./public/sitemap.xml，文件包含网站主体里的所有链接，点击Expand查看具体内容\nExpand ↕    xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"  https://opsbear2.com/mydocs/4.sitemap/ 2022-08-05T18:25:13+08:00  https://opsbear2.com/mydocs/ 2022-08-05T18:25:13+08:00  https://opsbear2.com/ 2022-08-05T18:25:13+08:00  https://opsbear2.com/prometheus/1.foreword/ 2022-08-05T16:46:51+08:00  https://opsbear2.com/prometheus/ 2022-08-05T16:46:51+08:00  https://opsbear2.com/mydocs/3.favicon/ 2022-08-03T18:26:38+08:00  https://opsbear2.com/kubernetes/2.containerconcept/ 2022-08-03T15:56:45+08:00  https://opsbear2.com/kubernetes/ 2022-08-03T15:56:45+08:00  https://opsbear2.com/windows/1.foreword/ 2022-08-02T11:02:43+08:00  https://opsbear2.com/windows/ 2022-08-02T11:02:43+08:00  https://opsbear2.com/mydocs/2.imagesbed/ 2022-08-01T22:01:36+08:00  https://opsbear2.com/mydocs/1.blogquickstart/ 2022-08-01T17:36:58+08:00  https://opsbear2.com/openvpn/1.quickstart/ 2022-07-31T14:29:33+08:00  https://opsbear2.com/openvpn/ 2022-07-31T14:29:33+08:00  https://opsbear2.com/frontpage/8.images/ 2022-07-29T16:20:07+08:00  https://opsbear2.com/frontpage/ 2022-07-29T16:20:07+08:00  https://opsbear2.com/frontpage/7.icons/ 2022-07-29T16:11:01+08:00  https://opsbear2.com/frontpage/6.buttons/ 2022-07-29T15:58:30+08:00  https://opsbear2.com/frontpage/5.columns/ 2022-07-29T15:52:56+08:00  https://opsbear2.com/frontpage/4.expand/ 2022-07-29T15:38:18+08:00  https://opsbear2.com/frontpage/3.hints/ 2022-07-29T15:22:07+08:00  https://opsbear2.com/frontpage/2.tags/ 2022-07-29T15:12:02+08:00  https://opsbear2.com/golang/1.foreword/ 2022-07-29T10:39:27+08:00  https://opsbear2.com/kubernetes/1.beginning/ 2022-07-29T10:39:27+08:00  https://opsbear2.com/golang/ 2022-07-29T10:39:27+08:00  https://opsbear2.com/python/1.foreword/ 2022-07-29T10:39:26+08:00  https://opsbear2.com/python/ 2022-07-29T10:39:26+08:00  https://opsbear2.com/frontpage/1.toc/ 2022-07-28T23:28:30+08:00  https://opsbear2.com/tags/      接下来需要将站点内容提交给搜索引擎收录，例如谷歌、百度等等\n谷歌收录入口   百度收录入口   以谷歌为例提交收录\n1.添加站点和txt认证\n2.新增Sitemap地址，提交\n地址：https://opsbear2.com/sitemap.xml\n3.验证收录结果\n浏览器输入site:yourwebsite，一般提交后n个自然日后会看到提交进度\n"},{"id":1,"href":"/mydocs/","title":"Mydocs","parent":"Welcome to Bear2's Secret Garden 💬🐻💬","content":"Sharing some Bear2\u0026rsquo;s articles for you\n"},{"id":2,"href":"/","title":"Welcome to Bear2's Secret Garden 💬🐻💬","parent":"","content":""},{"id":3,"href":"/mydocs/blog/","title":"搭建博客","parent":"Mydocs","content":"介绍基于Github Page + Hugo 搭建博客\n"},{"id":4,"href":"/prometheus/1.foreword/","title":"1.foreword","parent":"Prometheus","content":""},{"id":5,"href":"/prometheus/","title":"Prometheus","parent":"Welcome to Bear2's Secret Garden 💬🐻💬","content":"Demo collapsible menu entries.\n"},{"id":6,"href":"/mydocs/blog/3.favicon/","title":"3.个性化Favicon","parent":"搭建博客","content":"   1 什么是favicon 2 自定义网站图标  2.1 定位网页的favicon文件 2.2 favicon的本地资源 2.3 生成你的favicon文件 2.4 推送新的网站图标        1 什么是favicon     Favicon是favorites icon的缩写，亦被称为website icon（网页图标）、page icon（页面图标）或urlicon（URL图标）。Favicon是与某个网站或网页相关联的图标\n简单点就是它们\n2 自定义网站图标     个人博客搭建好了，想拥有个性化的网站图标怎么办，你只需要替换下原有favicon的文件即可\n2.1 定位网页的favicon文件     首先你需要知道你网站的favicon文件使用的格式，打开网页，F12进入开发者工具，找到Network，检索以favicon为前缀的资源文件，刷新网页重新请求资源，可以看到我的网站favicon文件是*.SVG格式，当然大部分网站的favicon都会采用这种格式，还有其他格式，比如*.ICO *.PNG等\n2.2 favicon的本地资源     查看favicon文件的header信息，也可以看到网页图标其实就是请求这个URL\nRequest URL: https://opsbear2.com/favicon/favicon.svg 那么这个文件在哪里呢？进入网站的家目录find遍历资源，可以看到public和themes目录下都有文件，在搭建Hugo+Github Page 架构的网站时，我们知道是把public目录下的静态页资源推送到Github，所以网站图标其实请求的就是./public/favicon/favicon.svg这个文件，而themes目录下的favicon.svg是Hugo构建静态页所需要的资源。如果想自定义网站图标，只需要将themes目录下的favicon.svg替换，Hugo -D重新构静态页，将新的资源再推送Github就可以了\nbear2 ~/git/blog find . -name \u0026#34;*favicon*\u0026#34; ./public/favicon ./public/favicon/favicon-16x16.png ./public/favicon/favicon.ico ./public/favicon/favicon-48x48.png ./public/favicon/favicon.svg ./public/favicon/favicon-32x32.png ./themes/hugo-geekdoc/layouts/partials/head/favicons.html ./themes/hugo-geekdoc/static/favicon ./themes/hugo-geekdoc/static/favicon/favicon-16x16.png ./themes/hugo-geekdoc/static/favicon/favicon.ico ./themes/hugo-geekdoc/static/favicon/favicon.svg ./themes/hugo-geekdoc/static/favicon/favicon-32x32.png ./themes/hugo-geekdoc/static/favicon.bak ./themes/hugo-geekdoc/static/favicon.bak/favicon-16x16.png ./themes/hugo-geekdoc/static/favicon.bak/favicon.ico ./themes/hugo-geekdoc/static/favicon.bak/favicon-48x48.png ./themes/hugo-geekdoc/static/favicon.bak/favicon.svg ./themes/hugo-geekdoc/static/favicon.bak/favicon-32x32.png 2.3 生成你的favicon文件     选好新的网站图标，按需将它转成*.ICO、*.SVG等格式\n这里推荐几个好用的网站， Favicon Generator   这个工具生成的文件可以满足大多数网站的所需的favicon资源\n或者你也可以使用格式转换工具，将*.PNG格式的图片直接转换成*.SVG，工具传送门🚪 convertio   2.4 推送新的网站图标     只需要以下几步你的网站将拥有新的图标\n1、将新生成的favicon文件放入以下目录./themes/hugo-geekdoc/static/favicon/（记得备份原始文件）\n2、hugo -D重新构建静态页，执行完成后可以去public目录确认下新的favicon是否生成\n3、git push origin master将新的资源推送至Github\n至此，你的网站已经拥有了新的图标，如果访问站点仍然是原来的图标，那一定是有缓存。如果你借助CloudFlare做了站点加速，那就去控制台清除下缓存吧\n"},{"id":7,"href":"/kubernetes/2.containerconcept/","title":"2.容器的本质","parent":"Kubernetes","content":"   1 什么是容器 2 容器的隔离性  2.1 为什么要隔离 2.2 与虚拟机的区别   3 隔离实现原理      1 什么是容器     从字面上来看，容器就是 Container，一般把它形象地比喻成现实世界里的集装箱，它也正好和 Docker 的现实含义相对应，因为码头工人（那只可爱的小鲸鱼）就是不停地在搬运集装箱\n集装箱的作用是标准化封装各种货物，一旦打包完成之后，就可以从一个地方迁移到任意的其他地方。相比散装形式而言，集装箱隔离了箱内箱外两个世界，保持了货物的原始形态，避免了内外部相互干扰，极大地简化了商品的存储、运输、管理等工作\n再回到我们的计算机世界，容器也发挥着同样的作用，不过它封装的货物是运行中的应用程序，也就是进程，同样它也会把进程与外界隔离开，让进程与外部系统互不影响\n实际看一下在容器里运行的进程\n使用 docker pull 命令，拉取一个新的镜像——操作系统 Alpine\n$ docker pull alpine 使用 docker run 命令运行它的 Shell 程序\n$ docker run -it alpine sh\t# -it参数，临时离开当前操作系统，进入容器内部 在容器里查看系统信息，会发现已经不再是外面的 Centos 系统了，而是变成了 Alpine Linux 3.15，使用 ps 命令也只会看到一个完全“干净”的运行环境，除了 Shell（即 sh）没有其他的进程存在，也就是说，在容器内部是一个全新的 Alpine 操作系统，在这里运行的应用程序完全看不到外面的 Ubuntu 系统，两个系统被互相“隔离”了，就像是一个“世外桃源”\n/ # cat /etc/os-release NAME=\u0026#34;Alpine Linux\u0026#34; ID=alpine VERSION_ID=3.16.1 PRETTY_NAME=\u0026#34;Alpine Linux v3.16\u0026#34; HOME_URL=\u0026#34;https://alpinelinux.org/\u0026#34; BUG_REPORT_URL=\u0026#34;https://gitlab.alpinelinux.org/alpine/aports/-/issues\u0026#34; / # ps PID USER TIME COMMAND 1 root 0:00 sh 8 root 0:00 ps 总结\n容器，就是一个特殊的隔离环境，它能够让进程只看到这个环境里的有限信息，与外部系统实现了隔离\n2 容器的隔离性     2.1 为什么要隔离     出于系统安全，在操作系统层面，需要做到隔离\n对于 Linux 操作系统来说，一个不受任何限制的应用程序是十分危险的。这个进程能够看到系统里所有的文件、所有的进程、所有的网络流量，访问内存里的任何数据，那么恶意程序很容易就会把系统搞瘫痪，正常程序也可能会因为无意的 Bug 导致信息泄漏或者其他安全事故。虽然 Linux 提供了用户权限控制，能够限制进程只访问某些资源，但这个机制还是比较薄弱的，和真正的“隔离”需求相差得很远\n使用容器技术，我们就可以让应用程序运行在一个有严密防护的“沙盒”（Sandbox）环境之内\n另外，在计算机里有各种各样的资源，CPU、内存、硬盘、网卡，虽然目前的高性能服务器都是几十核 CPU、上百 GB 的内存、数 TB 的硬盘、万兆网卡，但这些资源终究是有限的，而且考虑到成本，也不允许某个应用程序无限制地占用\n容器技术的另一个本领就是为应用程序加上资源隔离，在系统里切分出一部分资源，让它只能使用指定的配额，比如只能使用一个 CPU，只能使用 1GB 内存等等，就好像在隔离酒店里保证一日三餐，但想要吃山珍海味那是不行的。这样就可以避免容器内进程的过度系统消耗，充分利用计算机硬件，让有限的资源能够提供稳定可靠的服务\n2.2 与虚拟机的区别     容器和虚拟机面对的都是相同的问题，使用的也都是虚拟化技术，只是所在的层次不同.可以参考 Docker 官网上的两张图\n首先，容器和虚拟机的目的都是隔离资源，保证系统安全，然后是尽量提高资源的利用率\n虚拟机\n使用 VirtualBox/VMware 创建虚拟机，能够在宿主机系统里完整虚拟化出一套计算机硬件，在里面还能够安装任意的操作系统，这内外两个系统也同样是完全隔离，互不干扰\n而在数据中心的服务器上，虚拟机软件（即图中的 Hypervisor）同样可以把一台物理服务器虚拟成多台逻辑服务器，这些逻辑服务器彼此独立，可以按需分隔物理服务器的资源，为不同的用户所使用\n从实现的角度来看，虚拟机虚拟化出来的是硬件，需要在上面再安装一个操作系统后才能够运行应用程序，而硬件虚拟化和操作系统都比较“重”，会消耗大量的 CPU、内存、硬盘等系统资源，但这些消耗其实并没有带来什么价值，属于“重复劳动”和“无用功”，不过好处就是隔离程度非常高，每个虚拟机之间可以做到完全无干扰\n容器\n它直接利用了下层的计算机硬件和操作系统，因为比虚拟机少了一层，所以自然就会节约 CPU 和内存，显得非常轻量级，能够更高效地利用硬件资源。不过，因为多个容器共用操作系统内核，应用程序的隔离程度就没有虚拟机那么高了\n容器相比于虚拟机最大的优势体现在运行效率，同样的系统资源，虚拟机只能跑 3 个应用，其他的资源都用来支持虚拟机运行了，而容器则能够把这部分资源释放出来，同时运行 6 个应用\n不过，虚拟机和容器这两种技术也不是互相排斥的，它们完全可以结合起来使用，用虚拟机实现与宿主机的强隔离，然后在虚拟机里使用 Docker 容器来快速运行应用程序\n总结\n1.容器隔离的目的是为了系统安全，限制了进程能够访问的各种资源\n2.相比虚拟机技术，容器更加轻巧、更加高效，消耗的系统资源非常少，在云计算时代极具优势\n3 隔离实现原理     Linux 操作系统内核之中，为资源隔离提供了三种技术：namespace、cgroup、chroot\nnamespace 是 2002 年从 Linux 2.4.19 开始出现的，和编程语言里的 namespace 有点类似，它可以创建出独立的文件系统、主机名、进程号、网络等资源空间，相当于给进程盖了一间小板房，这样就实现了系统全局资源和进程局部资源的隔离\ncgroup 是 2008 年从 Linux 2.6.24 开始出现的，它的全称是 Linux Control Group，用来实现对进程的 CPU、内存等资源的优先级和配额限制，相当于给进程的小板房加了一个天花板\nchroot 的历史则要比前面的 namespace、cgroup 要古老得多，早在 1979 年的 UNIX V7 就已经出现了，它可以更改进程的根目录，也就是限制访问文件系统，相当于给进程的小板房铺上了地砖\n总结\n容器的基本实现技术是 Linux 系统里的 namespace、cgroup、chroot\n"},{"id":8,"href":"/kubernetes/","title":"Kubernetes","parent":"Welcome to Bear2's Secret Garden 💬🐻💬","content":"This page is an overview of Kubernetes.\nKubernetes is a portable, extensible, open source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available.\nThe name Kubernetes originates from Greek, meaning helmsman or pilot. K8s as an abbreviation results from counting the eight letters between the \u0026ldquo;K\u0026rdquo; and the \u0026ldquo;s\u0026rdquo;. Google open-sourced the Kubernetes project in 2014. Kubernetes combines over 15 years of Google\u0026rsquo;s experience running production workloads at scale with best-of-breed ideas and practices from the community.\n"},{"id":9,"href":"/windows/1.foreword/","title":"1.foreword","parent":"Windows","content":"Hello World     "},{"id":10,"href":"/windows/","title":"Windows","parent":"Welcome to Bear2's Secret Garden 💬🐻💬","content":"Windows Server is the platform for building an infrastructure of connected applications, networks, and web services. As a Windows Server administrator, you’ve helped achieve your business’ goals keeping the infrastructure secure, available, and flexible. Windows Server has been the foundation of Microsoft’s ecosystem and continues to power the hybrid cloud network today\n"},{"id":11,"href":"/mydocs/blog/2.imagesbed/","title":"2.GPT图床搭建教程","parent":"搭建博客","content":"   1 项目介绍 2 Github创建仓库 3 安装PicGo 4 集成Typora      1 项目介绍     博客中的图片该如何存储，本文将介绍基于Github+PicGo+Typora搭建的免费图床，保姆级别的搭建教程如下\n Q1：什么是Github+PicGo+Typora？\n  Github 是一个静态站点托管服务，直接将个人、组织或项目的页面托管于 GitHub 库或仓库 (repository) 中 PicGo 是一个用于快速上传图片并获取图片 URL 链接的工具 Typora 是一款轻便简洁的Markdown编辑器，支持即时渲染是它最大的特色  2 Github创建仓库     Github的仓库可以作为存放博客图片的后端，比起共享存储、自建nginx站点等方式，它最大的特点是免费（白嫖\n1.创建仓库，设置为公有访问\n2.创建token，用于PicGo访问\n【Settings】-\u0026gt;【Developer settings】-\u0026gt;【Personal access tokens】\n点击创建新的token，至此Github配置到此结束\n3 安装PicGo     1.下载PicGo\n你可以从PicGo官网下载软件，或者从第三方软件源下载，例如PicGo下载通道\n更多安装方式见PicGo官方文档传输门🚪 PicGoDocs   2.配置PicGo\n安装完成后，右侧点击【图床配置】，选择GitHub图床，填写以下信息\n 1.指定存储路径可以缺省\n2.自定义域名可以使用jsdelivr，它可以提供免费的CDN加速，配置方式如下：\nhttps://cdn.jsdelivr.net/gh/${username}/${repositories}   3.上传图片测试\nPicGo有多种图片上传方式，在这里我们使用最简单的图形界面测试上传功能，只需将图片拖拽到文件缓存区即可，上传过程中控制台下方会有蓝色进度条，建议开启MacOS系统对于PicGo App的通知，这样你可以更直观的知悉图片上传状态\n4.在Github上查看你上传的图片\n在不指定存储路径的情况下，图片文件会上传至Git仓库的家目录，当然你也可以创建二级目录让你的仓库看起来更整洁。以下示例是以~/default目录上传图片，在Github上的界面展示\n5.关于PicGo的插件\n你可以在PicGo官网 PicGoPlugins   里找到PicGo的插件和应用了PicGo的项目，在这里推荐一款自定义目录和文件前缀的插件PicGo-plugin-super-prefix 安装和配置方式如下\n在右侧【插件管理】，检索PicGo-plugin-super-prefix，点击安装\n安装完成后，在插件管理界面，点击右下角的设置，自定义目录和图片的前缀，参考配置如下：\n//super-prefix插件配置 \u0026#34;PicGo-plugin-super-prefix\u0026#34;: { \u0026#34;prefixFormat\u0026#34;: \u0026#34;YYYY-MM-DD/\u0026#34;\t//目录前缀 \u0026#34;fileFormat\u0026#34;: \u0026#34;YYYYMMDD-HHmmss\u0026#34;\t//文件前缀 } Github上目录和文件的命名展示效果如下\n你可以在/Users/${username}/Library/Application Support/PicGo/data.json文件中查看更多关于PicGo的功能配置，点击Expand查看具体配置\nExpand ↕  { \"picBed\": { \"current\": \"github\", \"uploader\": \"github\", \"smms\": { \"token\": \"\" }, \"github\": { \"branch\": \"master\", \"customUrl\": \"customUrl\", \"path\": \"default/\", \"repo\": \"opsbear2/ImagesForBlog\", \"token\": \"token\" }, \"list\": [ { \"name\": \"SM.MS图床\", \"type\": \"smms\", \"visible\": false }, { \"name\": \"腾讯云COS\", \"type\": \"tcyun\", \"visible\": false }, { \"name\": \"GitHub图床\", \"type\": \"github\", \"visible\": true }, { \"name\": \"七牛图床\", \"type\": \"qiniu\", \"visible\": false }, { \"name\": \"Imgur图床\", \"type\": \"imgur\", \"visible\": false }, { \"name\": \"阿里云OSS\", \"type\": \"aliyun\", \"visible\": false }, { \"name\": \"又拍云图床\", \"type\": \"upyun\", \"visible\": false } ] }, \"settings\": { \"shortKey\": { \"PicGo:upload\": { \"enable\": true, \"key\": \"CommandOrControl+Shift+P\", \"name\": \"upload\", \"label\": \"快捷上传\" } }, \"server\": { \"enable\": true, \"host\": \"127.0.0.1\", \"port\": 36677 }, \"privacyEnsure\": true, \"showUpdateTip\": true, \"uploadNotification\": true, \"logLevel\": [ \"all\" ], \"autoStart\": true, \"autoCopy\": false }, \"PicGoPlugins\": { \"PicGo-plugin-github-plus\": false, \"PicGo-plugin-super-prefix\": true, \"PicGo-plugin-watermark\": false }, \"debug\": true, \"PicGo_ENV\": \"GUI\", \"needReload\": false, \"PicGo-plugin-super-prefix\": { \"fileFormat\": \"YYYYMMDD-HHmmss\", \"prefixFormat\": \"YYYY-MM-DD/\" }, \"PicGo-plugin-watermark\": { \"fontFamily\": \"\", \"fontSize\": \"24px\", \"image\": \"\", \"minSize\": \"100*100\", \"position\": \"rb\", \"text\": \"@Bear2\", \"textColor\": \"#b2b2b2\" } }    到这里，基于Github+PicGo的图床就搭建完毕了，图床的更多场景是应用于博客的写作中，下面将介绍PicGo集成Typora 的用法\n4 集成Typora     经常写Markdown的朋友肯定知道这款软件，Typora是一款超级好用的编辑器，支持即时渲染是它最大的特色。你可以在Typora里联动PicGo，当你在编辑器中插入、粘贴图片时，Typora+PicGo可以自动把图片上传至Github保存\n1.安装Typora\n最新的Typora是付费版，旧版本仍然可以满足基础写作需求，下载地址如下\nhttps://www.macat.vip/10372.html\n2.配置Typora\n【Typora】-\u0026gt;【偏好设置】-\u0026gt;【图像】，插入图片时选择【上传图片】并勾选以下选项，上传服务设定选择【PicGo.app】\n设置完成，点击【验证图片上传】，提示上传成功，即代表配置成功\n3.关于PicGo端口设定\nTypora图片验证中的端口，需要与PicGo中的server设置的端口36677 保持一致，否则Typora就不能正常上传\nPicGo端口设置如下\n到这里，基于Github+PicGo+Typora的图床功能就搭建完成了，持续更新博客又是另一回事了，Cheers Up！\n"},{"id":12,"href":"/mydocs/blog/1.blogquickstart/","title":"1.基于Hugo+Github搭建博客","parent":"搭建博客","content":"   1 项目介绍 2 GitHub环境准备 3 安装Hugo 4 将网站推送至Github 5 添加文章 6 网站加速      1 项目介绍     本文介绍如何使用GitHub Pages+Hugo搭建个人博客\n Q1：什么是 GitHub Pages+Hugo ？\n  GitHub Pages 是一个静态站点托管服务，直接将个人、组织或项目的页面托管于 GitHub 库或仓库 (repository) 中 Hugo 是一个用 Go 语言编写的静态站点生成器，它针对速度、易用性和可配置性进行了优化，快速灵活  2 GitHub环境准备     在有GitHub账号的基础上，新建一个仓库，库名为${username}.github.io\n GitHub 仓库名必须为${username}.github.io，唯一值  3 安装Hugo     根据自己的操作系统，参考以下安装指南\nMacOS   你的Mac已安装Homebrew的情况下，在终端执行  brew install hugo 安装完成后，检查版本  hugo version   Windows  https://gohugo.io/getting-started/installing/  Linux  https://gohugo.io/getting-started/installing/   环境安装成功后，程序目录如下\nbear2 ~/git/blog ll total 40 drwxr-xr-x 3 bear2 staff 96B 7 28 15:14 archetypes -rw-r--r-- 1 bear2 staff 554B 7 31 15:06 config.toml -rw-r--r-- 1 bear2 staff 82B 7 28 15:15 config.toml.bak drwxr-xr-x 9 bear2 staff 288B 8 1 17:36 content -rwxr-xr-x@ 1 bear2 staff 1.5K 8 1 17:36 create_article.sh drwxr-xr-x 3 bear2 staff 96B 7 29 16:41 data -rwxr-xr-x 1 bear2 staff 455B 7 28 18:28 deploy.sh -rw-r--r-- 1 bear2 staff 84B 7 29 19:43 index.md drwxr-xr-x 2 bear2 staff 64B 7 28 15:14 layouts drwxr-xr-x 26 bear2 staff 832B 7 31 15:08 public drwxr-xr-x 3 bear2 staff 96B 7 28 15:16 resources drwxr-xr-x 2 bear2 staff 64B 7 28 15:14 static drwxr-xr-x 3 bear2 staff 96B 7 28 15:47 themes 搭建本地站点，为你的博客创建第一篇文章\nhugo new ${dir}/${article}   hugo new 会在hugo安装路径下创建一篇新文章，默认会在~/content/生成，添加 ${dir}后文章会在~/content/${dir}创建，非必选项  目录结构如下\nbear2 ~/git/blog/content ll total 0 drwxr-xr-x 4 bear2 staff 128B 8 1 18:23 bdocs drwxr-xr-x 12 bear2 staff 384B 7 31 14:08 frontpage drwxr-xr-x 4 bear2 staff 128B 7 31 14:16 golang drwxr-xr-x 4 bear2 staff 128B 7 31 14:20 kubernetes drwxr-xr-x 4 bear2 staff 128B 8 1 10:33 openvpn drwxr-xr-x 4 bear2 staff 128B 7 31 14:18 python 启动本地站点，访问http://localhost:1313/导航到你的网站\n# hugo server -D | EN +------------------+----+ Pages | 10 Paginator pages | 0 Non-page files | 0 Static files | 3 Processed images | 0 Aliases | 1 Sitemaps | 1 Cleaned | 0 Total in 11 ms Watching for changes in /Users/bep/quickstart/{content,data,layouts,static,themes} Watching for config changes in /Users/bep/quickstart/config.toml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 为你的博客选择合适的主题，我选择的主题是Geekdocs，界面简洁且优雅\n下载最新的发布包并将其解压到主题目录~/themes\nmkdir -p themes/hugo-geekdoc/ curl -L https://github.com/thegeeklab/hugo-geekdoc/releases/latest/download/hugo-geekdoc.tar.gz | tar -xz -C themes/hugo-geekdoc/ --strip-components=1   不推荐使用clone的方式，从Github克隆下的内容不是一个完整工程包，还需要单独构建其中的CSS和SVG文件，如果仍想使用该种方式，请参考以下官方文档\nhttps://geekdocs.de/usage/getting-started/#using-the-theme\n  Hugo添加主题相关配置，配置文件~/config.toml，修改之前请备份它\nbaseURL = \u0026#34;https://opsbear2.github.io\u0026#34; title = \u0026#34;Welcome to Bear2\u0026#39;s Secret Garden 💬🐻💬\u0026#34; theme = \u0026#34;hugo-geekdoc\u0026#34; pluralizeListTitles = false # Geekdoc required configuration pygmentsUseClasses = true pygmentsCodeFences = true disablePathToLower = true # Required if you want to render robots.txt template enableRobotsTXT = true # Needed for mermaid shortcodes [markup] [markup.goldmark.renderer] # Needed for mermaid shortcode unsafe = true [markup.tableOfContents] startLevel = 1 endLevel = 9 [taxonomies] tag = \u0026#34;tags\u0026#34; 更换自定义主题后需要重新构建静态页，启动本地环境访问站点查看效果\nhugo -D #构建静态页 hugo server -D #启动本地站点 至此，本地站点环境搭建完成，更多资料见官方文档传送门🚪\nHugo   Themes   Geekdocs   4 将网站推送至Github     在构建静态页后，会在~/public目录存放网站内容，需要将这些资源推送至Github\n进入~/public,初始化本地仓库\ngit init 添加需要上传的文件\ngit add . 提交文件到本地仓库\ngit commit -m \u0026#34;info\u0026#34; 关联远程仓库\ngit remote add origin git@github.com:${username}/${username}.github.io.git 提交内容\ngit push -u origin master 提交成功后，Github结构如下\n至此，个人博客搭建完成，你的博客地址是\nhttps://${username}.github.io\n5 添加文章     上面介绍了搭建个人博客的教程，如果想新增博客内容，参考以下内容\n新增文章的流程是在~/content目录下添加内容，一般是markdown格式的文档，你可以在本地目录下手动创建目录或者文章，当然也可以使用hugo new ${dir}/${article}，新增内容后使用hugo -D 重新构建静态页，将~/public下的内容提交到Github\n为了解放双手，以上流程已封装成脚本，包括创建文章和推送仓库\ncreate_article.sh 点击Expand展开\nExpand ↕  #!/bin/sh  # 使用脚本创建新的文章 if [ $# -ne 2 ];then echo \"\\033[33mUsage: sh $0dir article\\033[0m\" exit 1 fi # 定义文章目录和名称 dir=$1 article=$2 if [ ! -d content/$dir ];then echo \"\\033[32mInitializing new directory and article ... \\033[0m\" # 若是新目录,需要创建目录和索引文件 mkdir -p content/$dir \u0026\u0026 cp index.md content/$dir/_index.md first=${dir:0:1} #获取首字母 other=${dir:1} #获取其他字母 first_upper=$(echo $first | tr 'a-z' 'A-Z') #将首字符转换为大写 title=${first_upper}${other} #拼接首字母大写的目录名称 /usr/local/bin/gsed -i \"s/Default/$title/g\" content/$dir/_index.md #修改索引文件的title # 获取文章序列号 ls -l content/$dir/*.md |grep -v 'index' /dev/null if [ $? = 0 ];then num=$(cd content/$dir \u0026\u0026 ls -l *.md |grep -v 'index'| awk '{print $NF}'|awk -F '.' '{print $1}'| tail -1) num=$(($num+1)) else num=1 fi # 创建文章 hugo new $dir/${num}.${article}.md # echo \"hugo new $dir/${num}.${article}.md \" else # 获取文章序列号 ls -l content/$dir/*.md |grep -v 'index' /dev/null if [ $? = 0 ];then num=$(cd content/$dir \u0026\u0026 ls -l *.md |grep -v 'index'| awk '{print $NF}'|awk -F '.' '{print $1}'| tail -1) num=$(($num+1)) else num=1 fi # 创建文章 hugo new $dir/${num}.${article}.md # echo \"hugo new $dir/${num}.${article}.md \" fi    deploy.sh 点击Expand展开\nExpand ↕  #!/bin/sh  # If a command fails then the deploy stops # set -e # Print out commands before executing them # set -x printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" # Build the project. hugo -D # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date '+%Y-%m-%d %H:%M:%S')\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master     create_article.sh脚本的line17index.md文件，Hugo安装完默认不创建，如果想使用脚本生成文章，需要单独生成，然后复制到博客目录下命名_index.md作为隐藏文件，该文件是博客目录的配置文件，可以在里面定义一些功能，例如自定义目录名称、窗口折叠、模块介绍等  index.md文件内容\n---title:Default\t#博客目录名称geekdocCollapseSection:true#开启窗口折叠---Demo collapsible menu entries.\t#模块介绍参考示例\nbear2 ~/git/blog/content/bdocs ll total 32 -rw-r--r--@ 1 zhangyonggang staff 9.2K 8 1 19:43 1.blogquickstart.md -rw-r--r--@ 1 zhangyonggang staff 89B 8 1 17:44 _index.md bear2 ~/git/blog/content/bdocs cat _index.md --- title: Bdocs geekdocCollapseSection: true --- Sharing some Bear2\u0026#39;s articles in here 博客展示\n6 网站加速     GitHub Pages+Hugo整体搭建流程简单，基于Go语言编写的Hugo可以快速构建前端页面资源，由于后端依托在GitHub，国内访问站点存在一定的网络延迟，为此可以配置CDN加速来提高网站的访问效率，当然你需要一个可用域名以及CloudFlare账号（用于白嫖CDN加速）\n 建议从海外网站购买域名，可以省去一系列备案审核的不必要麻烦，个人推荐购买域名的网站Namesilo\nhttps://www.namesilo.com/\n  添加站点\n完成CloudFlare账号注册后，在控制台【网站】添加你的站点，站点地址是你的域名，例如opsbear2.com\n配置解析\n在【CDN】页面添加DNS解析\nA记录解析后，你的访问站点是http://opsbear2.com\nCNAME解析后，你的访问站点是http://www.opsbear2.com\n更多Github配置自定义域，参考官方文档 GithubDocs   加速原理\n在CDN配置页面，开启代理后，访问站点会先经过CloudFlare的节点，CloudFlare将网站内容的副本存储在全球分布的数据中心的服务器上，使访问网站更快。当然这是CloudFlare提供的免费服务，生命不止，白嫖不息！\n开启Https访问\n添加完站点和CDN解析后，CloudFlare还会免费提供一个SSL/TLS安全证书，需要调整以下配置，你的站点将开启更安全的Https访问\n 使用签名证书  开启自动重写  CloudFlare加速配置完成，最后在Github上添加自定义域即可\nGithub配置自定义域\n【Settings】-\u0026gt;【Pages】-\u0026gt;【Custom domain】，添加你的网站域名\n到这里，你的站点凭借CloudFlare白嫖资源完成了CDN访问加速！\n"},{"id":13,"href":"/openvpn/1.quickstart/","title":"1.openvpn部署文档","parent":"Openvpn","content":"   1 部署服务端  1.1 服务端环境准备 1.2 修改配置文件   2 部署客户端  2.1 客户端环境准备 2.2 连接服务端   3 其他配置  3.1 客户端提速 3.2 登录认证   4 脚本库  4.1 openvpn安装脚本 4.2 checkpsw认证        1 部署服务端     1.1 服务端环境准备     安装环境\n服务端 centos 7.2*1 10.17.0.10 客户端 centos 7.2*1 10.50.5.10 使用一键安装脚本，交互输入说明如下，执行过程中一直回车即可\nsh openvpn-install.sh \u0026gt;IP address: #脚本自动捕获 \u0026gt;Protocol [1-2]:1 #选择默认的udp协议 \u0026gt;Port: 1194 #默认端口 \u0026gt;DNS [1-5]: 1 #默认DNS \u0026gt;Client name: client #客户端配置文件名字,按需修改 脚本运行完，执行service iptables save查看nat转发规则\n# Generated by iptables-save v1.4.7 on Wed Oct 24 16:43:36 2018 *nat :PREROUTING ACCEPT [254:26292] :POSTROUTING ACCEPT [129:9143] :OUTPUT ACCEPT [129:9143] -A POSTROUTING -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to-source 10.17.0.10 COMMIT 调整安全组和iptables，放行udp:1194\n1.2 修改配置文件     openvpn服务端配置文件/etc/openvpn/server.conf\n默认配置基础下添加 \u0026gt;duplicate-cn #允许多个客户端同时连接，为客户端分配不同的ip 服务端配置文件修改完，需要重启openvpn\nsystemctl restart openvpn@server.service openvpn客户端配置文件/root/client.ovpn\n默认配置基础下添加 \u0026gt;route-nopull \u0026gt;route 10.17.0.0 255.255.0.0 vpn_gateway #默认访问网络不走vpn隧道,下发该路由后访问目的网络会自动进入VPN隧道 至此服务端搭建完成\n2 部署客户端     2.1 客户端环境准备     yum安装openvpn和依赖包\nyum -y install epel-release yum -y install openvpn 添加配置文件和证书，将服务端/etc/openvpn目录下的ca.crt ta.key client.ovpn文件拷贝到客户端\n[root@bear2 /etc/openvpn]#tree .  . ├── client │ ├── ca.crt #服务端提供 │ └── ta.key #服务端提供 ├── server └── client.ovpn #服务端提供 2.2 连接服务端     openvpn --daemon --config /etc/openvpn/client.ovpn --log-append /var/log/openvpn.log 连接后ifconfig后有一个tun0的虚拟网口，查看route -n会有对应访问服务端的路由规则\nDestination Gateway Genmask Flags Metric Ref Use Iface 10.8.0.0 0.0.0.0 255.255.255.0 U 0 0 0 tun0 10.17.0.0 10.8.0.1 255.255.0.0 UG 0 0 0 tun0 3 其他配置     3.1 客户端提速     server和client配置文件添加以下参数（windows client不兼容该参数） 配置说明：（仅限 Linux）在 TUN/TAP 接口上设置 TX 队列长度。当前默认为 100\ntxqueuelen 1000 3.2 登录认证     服务端添加以下配置，checkpsw.sh见脚本库，给可执行权限\nchmod 755 checkpsw.sh\nauth-user-pass-verify /etc/openvpn/checkpsw.sh via-env client-cert-not-required username-as-common-name script-security 3 客户端添加以下配置\nauth-user-pass 4 脚本库     4.1 openvpn安装脚本     点击Expand查看更多\nExpand ↕  #!/bin/bash  # Detect Debian users running the script with \"sh\" instead of bash if readlink /proc/$$/exe | grep -q \"dash\"; then echo \"This script needs to be run with bash, not sh\" exit fi if [[ \"$EUID\" -ne 0 ]]; then echo \"Sorry, you need to run this as root\" exit fi if [[ ! -e /dev/net/tun ]]; then echo \"The TUN device is not available You need to enable TUN before running this script\" exit fi if [[ -e /etc/debian_version ]]; then OS=debian GROUPNAME=nogroup RCLOCAL='/etc/rc.local' elif [[ -e /etc/centos-release || -e /etc/redhat-release ]]; then OS=centos GROUPNAME=nobody RCLOCAL='/etc/rc.d/rc.local' else echo \"Looks like you aren't running this installer on Debian, Ubuntu or CentOS\" exit fi newclient () { # Generates the custom client.ovpn cp /etc/openvpn/client-common.txt ~/$1.ovpn echo \"\"  ~/$1.ovpn cat /etc/openvpn/easy-rsa/pki/ca.crt  ~/$1.ovpn echo \"\"  ~/$1.ovpn echo \"\"  ~/$1.ovpn cat /etc/openvpn/easy-rsa/pki/issued/$1.crt  ~/$1.ovpn echo \"\"  ~/$1.ovpn echo \"\"  ~/$1.ovpn cat /etc/openvpn/easy-rsa/pki/private/$1.key  ~/$1.ovpn echo \"\"  ~/$1.ovpn echo \"\"  ~/$1.ovpn cat /etc/openvpn/ta.key  ~/$1.ovpn echo \"\"  ~/$1.ovpn } if [[ -e /etc/openvpn/server.conf ]]; then while : do clear echo \"Looks like OpenVPN is already installed.\" echo echo \"What do you want to do?\" echo \" 1) Add a new user\" echo \" 2) Revoke an existing user\" echo \" 3) Remove OpenVPN\" echo \" 4) Exit\" read -p \"Select an option [1-4]: \" option case $option in 1) echo echo \"Tell me a name for the client certificate.\" echo \"Please, use one word only, no special characters.\" read -p \"Client name: \" -e CLIENT cd /etc/openvpn/easy-rsa/ EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-client-full $CLIENT nopass # Generates the custom client.ovpn newclient \"$CLIENT\" echo echo \"Client $CLIENTadded, configuration is available at:\" ~/\"$CLIENT.ovpn\" exit ;; 2) # This option could be documented a bit better and maybe even be simplified # ...but what can I say, I want some sleep too NUMBEROFCLIENTS=$(tail -n +2 /etc/openvpn/easy-rsa/pki/index.txt | grep -c \"^V\") if [[ \"$NUMBEROFCLIENTS\" = '0' ]]; then echo echo \"You have no existing clients!\" exit fi echo echo \"Select the existing client certificate you want to revoke:\" tail -n +2 /etc/openvpn/easy-rsa/pki/index.txt | grep \"^V\" | cut -d '=' -f 2 | nl -s ') ' if [[ \"$NUMBEROFCLIENTS\" = '1' ]]; then read -p \"Select one client [1]: \" CLIENTNUMBER else read -p \"Select one client [1-$NUMBEROFCLIENTS]: \" CLIENTNUMBER fi CLIENT=$(tail -n +2 /etc/openvpn/easy-rsa/pki/index.txt | grep \"^V\" | cut -d '=' -f 2 | sed -n \"$CLIENTNUMBER\"p) echo read -p \"Do you really want to revoke access for client $CLIENT? [y/N]: \" -e REVOKE if [[ \"$REVOKE\" = 'y' || \"$REVOKE\" = 'Y' ]]; then cd /etc/openvpn/easy-rsa/ ./easyrsa --batch revoke $CLIENT EASYRSA_CRL_DAYS=3650 ./easyrsa gen-crl rm -f pki/reqs/$CLIENT.req rm -f pki/private/$CLIENT.key rm -f pki/issued/$CLIENT.crt rm -f /etc/openvpn/crl.pem cp /etc/openvpn/easy-rsa/pki/crl.pem /etc/openvpn/crl.pem # CRL is read with each client connection, when OpenVPN is dropped to nobody chown nobody:$GROUPNAME /etc/openvpn/crl.pem echo echo \"Certificate for client $CLIENTrevoked!\" else echo echo \"Certificate revocation for client $CLIENTaborted!\" fi exit ;; 3) echo read -p \"Do you really want to remove OpenVPN? [y/N]: \" -e REMOVE if [[ \"$REMOVE\" = 'y' || \"$REMOVE\" = 'Y' ]]; then PORT=$(grep '^port ' /etc/openvpn/server.conf | cut -d \" \" -f 2) PROTOCOL=$(grep '^proto ' /etc/openvpn/server.conf | cut -d \" \" -f 2) if pgrep firewalld; then IP=$(firewall-cmd --direct --get-rules ipv4 nat POSTROUTING | grep '\\-s 10.8.0.0/24 '\"'\"'!'\"'\"' -d 10.8.0.0/24 -j SNAT --to ' | cut -d \" \" -f 10) # Using both permanent and not permanent rules to avoid a firewalld reload. firewall-cmd --zone=public --remove-port=$PORT/$PROTOCOL firewall-cmd --zone=trusted --remove-source=10.8.0.0/24 firewall-cmd --permanent --zone=public --remove-port=$PORT/$PROTOCOL firewall-cmd --permanent --zone=trusted --remove-source=10.8.0.0/24 firewall-cmd --direct --remove-rule ipv4 nat POSTROUTING 0 -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to $IP firewall-cmd --permanent --direct --remove-rule ipv4 nat POSTROUTING 0 -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to $IP else IP=$(grep 'iptables -t nat -A POSTROUTING -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to ' $RCLOCAL | cut -d \" \" -f 14) iptables -t nat -D POSTROUTING -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to $IP sed -i '/iptables -t nat -A POSTROUTING -s 10.8.0.0\\/24 ! -d 10.8.0.0\\/24 -j SNAT --to /d' $RCLOCAL if iptables -L -n | grep -qE '^ACCEPT'; then iptables -D INPUT -p $PROTOCOL --dport $PORT -j ACCEPT iptables -D FORWARD -s 10.8.0.0/24 -j ACCEPT iptables -D FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT sed -i \"/iptables -I INPUT -p $PROTOCOL--dport $PORT-j ACCEPT/d\" $RCLOCAL sed -i \"/iptables -I FORWARD -s 10.8.0.0\\/24 -j ACCEPT/d\" $RCLOCAL sed -i \"/iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT/d\" $RCLOCAL fi fi if sestatus 2/dev/null | grep \"Current mode\" | grep -q \"enforcing\" \u0026\u0026 [[ \"$PORT\" != '1194' ]]; then semanage port -d -t openvpn_port_t -p $PROTOCOL $PORT fi if [[ \"$OS\" = 'debian' ]]; then apt-get remove --purge -y openvpn else yum remove openvpn -y fi rm -rf /etc/openvpn rm -f /etc/sysctl.d/30-openvpn-forward.conf echo echo \"OpenVPN removed!\" else echo echo \"Removal aborted!\" fi exit ;; 4) exit;; esac done else clear echo 'Welcome to this OpenVPN \"road warrior\" installer!' echo # OpenVPN setup and first user creation echo \"I need to ask you a few questions before starting the setup.\" echo \"You can leave the default options and just press enter if you are ok with them.\" echo echo \"First, provide the IPv4 address of the network interface you want OpenVPN\" echo \"listening to.\" # Autodetect IP address and pre-fill for the user IP=$(ip addr | grep 'inet' | grep -v inet6 | grep -vE '127\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}' | grep -oE '[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}' | head -1) read -p \"IP address: \" -e -i $IP IP # If $IP is a private IP address, the server must be behind NAT if echo \"$IP\" | grep -qE '^(10\\.|172\\.1[6789]\\.|172\\.2[0-9]\\.|172\\.3[01]\\.|192\\.168)'; then echo echo \"This server is behind NAT. What is the public IPv4 address or hostname?\" read -p \"Public IP address / hostname: \" -e PUBLICIP fi echo echo \"Which protocol do you want for OpenVPN connections?\" echo \" 1) UDP (recommended)\" echo \" 2) TCP\" read -p \"Protocol [1-2]: \" -e -i 1 PROTOCOL case $PROTOCOL in 1) PROTOCOL=udp ;; 2) PROTOCOL=tcp ;; esac echo echo \"What port do you want OpenVPN listening to?\" read -p \"Port: \" -e -i 1194 PORT echo echo \"Which DNS do you want to use with the VPN?\" echo \" 1) Current system resolvers\" echo \" 2) 1.1.1.1\" echo \" 3) Google\" echo \" 4) OpenDNS\" echo \" 5) Verisign\" read -p \"DNS [1-5]: \" -e -i 1 DNS echo echo \"Finally, tell me your name for the client certificate.\" echo \"Please, use one word only, no special characters.\" read -p \"Client name: \" -e -i client CLIENT echo echo \"Okay, that was all I needed. We are ready to set up your OpenVPN server now.\" read -n1 -r -p \"Press any key to continue...\" if [[ \"$OS\" = 'debian' ]]; then apt-get update apt-get install openvpn iptables openssl ca-certificates -y else # Else, the distro is CentOS yum install epel-release -y yum install openvpn iptables openssl ca-certificates -y fi # Get easy-rsa EASYRSAURL='https://github.com/OpenVPN/easy-rsa/releases/download/v3.0.5/EasyRSA-nix-3.0.5.tgz' wget -O ~/easyrsa.tgz \"$EASYRSAURL\" 2/dev/null || curl -Lo ~/easyrsa.tgz \"$EASYRSAURL\" tar xzf ~/easyrsa.tgz -C ~/ mv ~/EasyRSA-3.0.5/ /etc/openvpn/ mv /etc/openvpn/EasyRSA-3.0.5/ /etc/openvpn/easy-rsa/ chown -R root:root /etc/openvpn/easy-rsa/ rm -f ~/easyrsa.tgz cd /etc/openvpn/easy-rsa/ # Create the PKI, set up the CA and the server and client certificates ./easyrsa init-pki ./easyrsa --batch build-ca nopass EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-server-full server nopass EASYRSA_CERT_EXPIRE=3650 ./easyrsa build-client-full $CLIENT nopass EASYRSA_CRL_DAYS=3650 ./easyrsa gen-crl # Move the stuff we need cp pki/ca.crt pki/private/ca.key pki/issued/server.crt pki/private/server.key pki/crl.pem /etc/openvpn # CRL is read with each client connection, when OpenVPN is dropped to nobody chown nobody:$GROUPNAME /etc/openvpn/crl.pem # Generate key for tls-auth openvpn --genkey --secret /etc/openvpn/ta.key # Create the DH parameters file using the predefined ffdhe2048 group echo '-----BEGIN DH PARAMETERS----- MIIBCAKCAQEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz +8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a 87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7 YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi 7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaD ssbzSibBsu/6iGtCOGEoXJf//////////wIBAg== -----END DH PARAMETERS-----'  /etc/openvpn/dh.pem # Generate server.conf echo \"port $PORTproto $PROTOCOLdev tun sndbuf 0 rcvbuf 0 ca ca.crt cert server.crt key server.key dh dh.pem auth SHA512 tls-auth ta.key 0 topology subnet server 10.8.0.0 255.255.255.0 ifconfig-pool-persist ipp.txt\"  /etc/openvpn/server.conf echo 'push \"redirect-gateway def1 bypass-dhcp\"'  /etc/openvpn/server.conf # DNS case $DNS in 1) # Locate the proper resolv.conf # Needed for systems running systemd-resolved if grep -q \"127.0.0.53\" \"/etc/resolv.conf\"; then RESOLVCONF='/run/systemd/resolve/resolv.conf' else RESOLVCONF='/etc/resolv.conf' fi # Obtain the resolvers from resolv.conf and use them for OpenVPN grep -v '#' $RESOLVCONF | grep 'nameserver' | grep -E -o '[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}' | while read line; do echo \"push \\\"dhcp-option DNS $line\\\"\"  /etc/openvpn/server.conf done ;; 2) echo 'push \"dhcp-option DNS 1.1.1.1\"'  /etc/openvpn/server.conf echo 'push \"dhcp-option DNS 1.0.0.1\"'  /etc/openvpn/server.conf ;; 3) echo 'push \"dhcp-option DNS 8.8.8.8\"'  /etc/openvpn/server.conf echo 'push \"dhcp-option DNS 8.8.4.4\"'  /etc/openvpn/server.conf ;; 4) echo 'push \"dhcp-option DNS 208.67.222.222\"'  /etc/openvpn/server.conf echo 'push \"dhcp-option DNS 208.67.220.220\"'  /etc/openvpn/server.conf ;; 5) echo 'push \"dhcp-option DNS 64.6.64.6\"'  /etc/openvpn/server.conf echo 'push \"dhcp-option DNS 64.6.65.6\"'  /etc/openvpn/server.conf ;; esac echo \"keepalive 10 120 cipher AES-256-CBC user nobody group $GROUPNAMEpersist-key persist-tun status openvpn-status.log verb 3 crl-verify crl.pem\"  /etc/openvpn/server.conf # Enable net.ipv4.ip_forward for the system echo 'net.ipv4.ip_forward=1'  /etc/sysctl.d/30-openvpn-forward.conf # Enable without waiting for a reboot or service restart echo 1  /proc/sys/net/ipv4/ip_forward if pgrep firewalld; then # Using both permanent and not permanent rules to avoid a firewalld # reload. # We don't use --add-service=openvpn because that would only work with # the default port and protocol. firewall-cmd --zone=public --add-port=$PORT/$PROTOCOL firewall-cmd --zone=trusted --add-source=10.8.0.0/24 firewall-cmd --permanent --zone=public --add-port=$PORT/$PROTOCOL firewall-cmd --permanent --zone=trusted --add-source=10.8.0.0/24 # Set NAT for the VPN subnet firewall-cmd --direct --add-rule ipv4 nat POSTROUTING 0 -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to $IP firewall-cmd --permanent --direct --add-rule ipv4 nat POSTROUTING 0 -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to $IP else # Needed to use rc.local with some systemd distros if [[ \"$OS\" = 'debian' \u0026\u0026 ! -e $RCLOCAL ]]; then echo '#!/bin/sh -e exit 0'  $RCLOCAL fi chmod +x $RCLOCAL # Set NAT for the VPN subnet iptables -t nat -A POSTROUTING -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to $IP sed -i \"1 a\\iptables -t nat -A POSTROUTING -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to $IP\" $RCLOCAL if iptables -L -n | grep -qE '^(REJECT|DROP)'; then # If iptables has at least one REJECT rule, we asume this is needed. # Not the best approach but I can't think of other and this shouldn't # cause problems. iptables -I INPUT -p $PROTOCOL --dport $PORT -j ACCEPT iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT sed -i \"1 a\\iptables -I INPUT -p $PROTOCOL--dport $PORT-j ACCEPT\" $RCLOCAL sed -i \"1 a\\iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT\" $RCLOCAL sed -i \"1 a\\iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT\" $RCLOCAL fi fi # If SELinux is enabled and a custom port was selected, we need this if sestatus 2/dev/null | grep \"Current mode\" | grep -q \"enforcing\" \u0026\u0026 [[ \"$PORT\" != '1194' ]]; then # Install semanage if not already present if ! hash semanage 2/dev/null; then yum install policycoreutils-python -y fi semanage port -a -t openvpn_port_t -p $PROTOCOL $PORT fi # And finally, restart OpenVPN if [[ \"$OS\" = 'debian' ]]; then # Little hack to check for systemd if pgrep systemd-journal; then systemctl restart openvpn@server.service else /etc/init.d/openvpn restart fi else if pgrep systemd-journal; then systemctl restart openvpn@server.service systemctl enable openvpn@server.service else service openvpn restart chkconfig openvpn on fi fi # If the server is behind a NAT, use the correct IP address if [[ \"$PUBLICIP\" != \"\" ]]; then IP=$PUBLICIP fi # client-common.txt is created so we have a template to add further users later echo \"client dev tun proto $PROTOCOLsndbuf 0 rcvbuf 0 remote $IP$PORTresolv-retry infinite nobind persist-key persist-tun remote-cert-tls server auth SHA512 cipher AES-256-CBC setenv opt block-outside-dns key-direction 1 verb 3\"  /etc/openvpn/client-common.txt # Generates the custom client.ovpn newclient \"$CLIENT\" echo echo \"Finished!\" echo echo \"Your client configuration is available at:\" ~/\"$CLIENT.ovpn\" echo \"If you want to add more clients, you simply need to run this script again!\" fi    4.2 checkpsw认证     点击Expand查看更多\nExpand ↕  #!/bin/bash ########################################################### # checkpsw.sh (C) 2004 Mathias Sundman  # # This script will authenticate OpenVPN users against # a plain text file. The passfile should simply contain # one row per user with the username first followed by # one or more space(s) or tab(s) and then the password. PASSFILE=\"/etc/openvpn/psw-file\" LOG_FILE=\"/etc/openvpn/openvpn-password.log\" TIME_STAMP=`date \"+%Y-%m-%d %T\"` ########################################################### if [ ! -r \"${PASSFILE}\" ]; then echo \"${TIME_STAMP}: Could not open password file \\\"${PASSFILE}\\\" for reading.\"  ${LOG_FILE} exit 1 fi CORRECT_PASSWORD=`awk '!/^;/\u0026\u0026!/^#/\u0026\u0026$1==\"'${username}'\"{print $2;exit}' ${PASSFILE}` if [ \"${CORRECT_PASSWORD}\" = \"\" ]; then echo \"${TIME_STAMP}: User does not exist: username=\\\"${username}\\\", password=\\\"${password}\\\".\"  ${LOG_FILE} exit 1 fi if [ \"${password}\" = \"${CORRECT_PASSWORD}\" ]; then echo \"${TIME_STAMP}: Successful authentication: username=\\\"${username}\\\".\"  ${LOG_FILE} exit 0 fi echo \"${TIME_STAMP}: Incorrect password: username=\\\"${username}\\\", password=\\\"${password}\\\".\"  ${LOG_FILE} exit 1    "},{"id":14,"href":"/openvpn/","title":"Openvpn","parent":"Welcome to Bear2's Secret Garden 💬🐻💬","content":"OpenVPN is an open source VPN daemon by James Yonan. Because OpenVPN tries to be a universal VPN tool offering a great deal of flexibility, there are a lot of options on this manual page. If you\u0026rsquo;re new to OpenVPN, you might want to skip ahead to the examples section where you will see how to construct simple VPNs on the command line without even needing a configuration file.\nAlso note that there\u0026rsquo;s more documentation and examples on the OpenVPN web site: https://openvpn.net/\nAnd if you would like to see a shorter version of this manual, see the openvpn usage message which can be obtained by running openvpn without any parameters.\n"},{"id":15,"href":"/frontpage/8.images/","title":"8.图片","parent":"Frontpage","content":"插入图片，可以是本地图片，也可以外部图片\n用法     ![imagesname](url) 例子     熊小二在看雪\n"},{"id":16,"href":"/frontpage/","title":"Frontpage","parent":"Welcome to Bear2's Secret Garden 💬🐻💬","content":"介绍Geekdocs下markdown的语法\n"},{"id":17,"href":"/frontpage/7.icons/","title":"7.图标","parent":"Frontpage","content":"引用图标，这些图标可以是geekdocs自带的，当然你也可以自定义，但必须是SVG格式\n{{\u0026lt; icon \u0026#34;thumbs-up\u0026#34; \u0026gt;}}用法        Result Usage      {{\u0026lt; icon \u0026quot;thumbs-up\u0026quot; \u0026gt;}}    {{\u0026lt; icon \u0026quot;thumbs-down\u0026quot; \u0026gt;}}    {{\u0026lt; icon \u0026quot;laugh\u0026quot; \u0026gt;}}    {{\u0026lt; icon \u0026quot;lemon\u0026quot; \u0026gt;}}    {{\u0026lt; icon \u0026quot;moon\u0026quot; \u0026gt;}}    "},{"id":18,"href":"/frontpage/6.buttons/","title":"6.按钮","parent":"Frontpage","content":"点击按钮可以指向本地页面\n{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;, size=\u0026#34;large|regular\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}}Get Home   或者外部链接\n{{\u0026lt; button href=\u0026#34;https://www.bilibili.com\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}B站传送门   在新标签打开链接\n\u0026lt;a href=\u0026#34;https://www.bilibili.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;Contribute\u0026lt;/a\u0026gt; B站传送门\n"},{"id":19,"href":"/frontpage/5.columns/","title":"5.多列","parent":"Frontpage","content":"并排（水平）组织内容以提高可读性\n属性        Name Description default     size (optional) size of the first column (small|regular|large) regular    用法     {{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; ## Left Content 至若春和景明，波澜不惊，上下天光，一碧万顷 ... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; ## Mid Content 至若春和景明，波澜不惊，上下天光，一碧万顷 ... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; ## Right Content 至若春和景明，波澜不惊，上下天光，一碧万顷 ... {{\u0026lt; /columns \u0026gt;}} 例子     左     庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴，乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上，属予作文以记之。\n予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯，朝晖夕阴，气象万千，此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？\n 中     若夫淫雨霏霏，连月不开，阴风怒号，浊浪排空，日星隐曜，山岳潜形，商旅不行，樯倾楫摧，薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣，至若春和景明，波澜不惊，上下天光，一碧万顷，沙鸥翔集，锦鳞游泳，岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。  右     嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲，居庙堂之高则忧其民，处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎！噫！微斯人，吾谁与归？\n时六年九月十五日。\n  "},{"id":20,"href":"/frontpage/4.expand/","title":"4.隐藏","parent":"Frontpage","content":"通过隐藏部分文本来帮助减少屏幕上的混乱，通过单击展开内容\n例子     默认     {{\u0026lt; expand \u0026gt;}}## 内容 嗟夫！予尝求古仁人之心，或异二者之为 ... {{\u0026lt; /expand \u0026gt;}}Expand ↕  内容     嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲，居庙堂之高则忧其民，处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎！噫！微斯人，吾谁与归？   自定义标签     {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}}## 内容 嗟夫！予尝求古仁人之心，或异二者之为 ... {{\u0026lt; /expand \u0026gt;}}点击查看原文 ...  原文     庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴，乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上，属予作文以记之。\n予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯，朝晖夕阴，气象万千，此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？\n若夫淫雨霏霏，连月不开，阴风怒号，浊浪排空，日星隐曜，山岳潜形，商旅不行，樯倾楫摧，薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。\n至若春和景明，波澜不惊，上下天光，一碧万顷，沙鸥翔集，锦鳞游泳，岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。\n嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲，居庙堂之高则忧其民，处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎！噫！微斯人，吾谁与归？\n时六年九月十五日\n  "},{"id":21,"href":"/frontpage/3.hints/","title":"3.提示","parent":"Frontpage","content":"设定不同的提示，种类包括提示/警报/通知\n属性        Name Description default     type hint type note   icon (optional) custom icon to use,need to be an icon from an SVG sprite undefined   title (optional) hint title undefined    用法     {{\u0026lt; hint type=tip \u0026gt;}}content {{\u0026lt; /hint \u0026gt;}}例子     {{\u0026lt; hint type=[note|tip|important|caution|warning] (icon=gdoc_github) (title=GitHub) \u0026gt;}}先天下之忧而忧，后天下之乐而乐 {{\u0026lt; /hint \u0026gt;}} 内容\n先天下之忧而忧，后天下之乐而乐   内容\n先天下之忧而忧，后天下之乐而乐   内容\n先天下之忧而忧，后天下之乐而乐   内容\n先天下之忧而忧，后天下之乐而乐   内容\n先天下之忧而忧，后天下之乐而乐  使用自定义的icon图标{{\u0026lt; hint type=note icon=gdoc_github title=GitHub \u0026gt;}}\n GitHub 内容\n先天下之忧而忧，后天下之乐而乐  "},{"id":22,"href":"/frontpage/2.tags/","title":"2.标签","parent":"Frontpage","content":"选项卡可让您按上下文组织内容，例如不同语言版本的《岳阳楼记》\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}}{{\u0026lt; tab \u0026#34;tag\u0026#34; \u0026gt;}}content {{\u0026lt; /tab \u0026gt;}}{{\u0026lt; /tabs \u0026gt;}}例子     {{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}}{{\u0026lt; tab \u0026#34;简体中文\u0026#34; \u0026gt;}}# 《岳阳楼记》 {{\u0026lt; /tab \u0026gt;}}{{\u0026lt; tab \u0026#34;英语\u0026#34; \u0026gt;}}# 《The Story of Yueyang Tower》 {{\u0026lt; /tab \u0026gt;}}{{\u0026lt; tab \u0026#34;法语\u0026#34; \u0026gt;}}# 《L\u0026#39;histoire de la tour Yueyang》 {{\u0026lt; /tab \u0026gt;}}{{\u0026lt; /tabs \u0026gt;}}简体中文  《岳阳楼记》     庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴，乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上，属予作文以记之。\n予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯，朝晖夕阴，气象万千，此则岳阳楼之大观也，前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？\n若夫淫雨霏霏，连月不开，阴风怒号，浊浪排空，日星隐曜，山岳潜形，商旅不行，樯倾楫摧，薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。\n至若春和景明，波澜不惊，上下天光，一碧万顷，沙鸥翔集，锦鳞游泳，岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。\n嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲，居庙堂之高则忧其民，处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎！噫！微斯人，吾谁与归？\n时六年九月十五日\n 英语  《The Story of Yueyang Tower》     In the spring of the fourth year of Qingli, Teng Zijing was exiled to guard Baling County. In the next year, the government will be harmonious, and the waste will be prosperous, so the Yueyang Tower will be rebuilt, the old system will be added, and the poems of Tang Xianjinren will be engraved on it, which belongs to the composition to remember.\nI watched the victorious state of my husband Baling, in a lake in Dongting. The title of distant mountains, swallowing the Yangtze River, the vast soup and soup, the boundless horizon, the dawn and the sunset, the weather is myriad, this is the grand view of Yueyang Tower, and the predecessors have prepared it. However, Wu Gorge in the north, Xiaoxiang in the Antarctic, and people who moved to the west would often come here.\nIf the husband is promiscuous, the rain is falling, the months are not open, the wind is roaring, the turbid waves are emptying, the sun and stars are hidden, the mountains are hidden, the business travel is not possible, the trees are devastated, the twilight is dark, and the tigers are roaring. In Dengsilou, there are those who go to the country and nostalgic, worry about slander and fear of ridicule, and their eyes are full of sadness.\nUntil Ruochun and Jingming, the waves are calm, the sky is bright, the sky is full of blue, the sea gulls are gathering, the golden scales are swimming, the shore is full of green and green. Or the long smoke is empty, the bright moon is a thousand miles away, the floating light leaps to gold, the still shadow sinks into the jade, the fisherman\u0026rsquo;s song answers each other, what a joy! Dengsilou also, there are those who are relaxed and happy, forget the favor and humiliation, and drink wine in the wind, and they are full of joy.\nOuch! I have tried to seek the heart of ancient benevolent people, or to act differently from the two, what is it? Don\u0026rsquo;t be happy with things, don\u0026rsquo;t be sad about yourself, you are worried about the people when you live in a temple, and you are worried about your ruler when you live far away from the rivers and lakes. It is worrying about advancing and worrying about retreating. But when will you be happy? It must be said, \u0026ldquo;The worry of the world first, the worry of the world, and the joy of the world\u0026rdquo;! Alas! Micro man, who I go?\nSeptember 15, six years\n 法语  《L\u0026rsquo;histoire de la tour Yueyang》     Au printemps de la quatrième année de Qingli, Teng Zijing fut exilé pour garder le comté de Baling. L\u0026rsquo;année prochaine, le gouvernement sera harmonieux et les déchets seront prospères. La tour Yueyang sera donc reconstruite, l\u0026rsquo;ancien système sera ajouté et les poèmes de Tang Xianjinren y seront gravés, ce qui appartient à la composition. se souvenir.\nJ\u0026rsquo;ai observé l\u0026rsquo;état victorieux de mon mari Baling, dans un lac à Dongting. Le titre des montagnes lointaines, avalant le fleuve Yangtze, la vaste soupe et soupe, l\u0026rsquo;horizon sans limites, le soleil du matin et le coucher du soleil, le temps est myriade, c\u0026rsquo;est la vue grandiose de la tour Yueyang, et les prédécesseurs l\u0026rsquo;ont préparée. Cependant, les gorges de Wu au nord, Xiaoxiang dans l\u0026rsquo;Antarctique et les personnes qui se sont déplacées vers l\u0026rsquo;ouest venaient souvent ici.\nSi le mari est promiscuité, la pluie tombe, les mois ne sont pas ouverts, le vent gronde, les vagues troubles se vident, le soleil et les étoiles sont cachés, les montagnes sont cachées, les voyages d\u0026rsquo;affaires ne sont pas possibles, les arbres sont dévasté, le crépuscule est sombre et les tigres rugissent. A Dengsilou, il y a ceux qui vont à la campagne et qui sont nostalgiques, s\u0026rsquo;inquiètent de la calomnie et ont peur du ridicule, et leurs yeux sont pleins de tristesse.\nJusqu\u0026rsquo;à Ruochun et Jingming, les vagues sont calmes, le ciel est lumineux, le ciel est plein de bleu, les mouettes se rassemblent, les écailles dorées nagent, le rivage est plein de vert et de vert. Ou la longue fumée est vide, la lune brillante est à des milliers de kilomètres, la lumière flottante bondit vers l\u0026rsquo;or, l\u0026rsquo;ombre immobile s\u0026rsquo;enfonce dans le jade, la chanson du pêcheur se répond, quelle joie ! Dengsilou aussi, il y a ceux qui sont détendus et heureux, oublient la faveur et l\u0026rsquo;humiliation, et boivent du vin dans le vent, et ils sont pleins de joie.\nAie! J\u0026rsquo;ai essayé de chercher le cœur d\u0026rsquo;anciens gens bienveillants, ou d\u0026rsquo;agir différemment des deux, qu\u0026rsquo;est-ce que c\u0026rsquo;est ? Ne sois pas content des choses, ne sois pas triste pour toi-même, tu t\u0026rsquo;inquiètes pour les gens quand tu vis dans un temple, et tu t\u0026rsquo;inquiètes pour ton dirigeant quand tu vis loin des rivières et des lacs. C\u0026rsquo;est s\u0026rsquo;inquiéter d\u0026rsquo;avancer et s\u0026rsquo;inquiéter de reculer. Mais quand serez-vous heureux ? Il faut dire : « L\u0026rsquo;inquiétude du monde d\u0026rsquo;abord, l\u0026rsquo;inquiétude du monde, et la joie du monde » ! Hélas! Micro homme, qui je vais?\n15 septembre, six ans\n  "},{"id":23,"href":"/golang/1.foreword/","title":"1.foreword","parent":"Golang","content":""},{"id":24,"href":"/kubernetes/1.beginning/","title":"1.初识容器","parent":"Kubernetes","content":"   1 初始容器 2 Docker的安装  2.1 手动安装 2.2 自动安装 2.3 卸载docker   3 Docker的简单使用 4 Docker的架构      1 初始容器     在学习Kubernetes之前，先从最简单、最基本的知识入手，聊聊最流行的容器技术 Docker\nDocker的形态\n目前使用 Docker 基本上有两个选择：Docker Desktop 和 Docker Engine\nDocker Desktop 是专门针对个人使用而设计的，支持 Mac 和 Windows 快速安装，具有直观的图形界面，还集成了许多周边工具，方便易用，但是太推荐使用 Docker Desktop，原因有两个。第一个，它是商业产品，难免会带有 Docker 公司的“私人气息”，有一些自己的、非通用的东西，不利于我们后续的 Kubernetes 学习。第二个，它只是对个人学习免费，受条款限制不能商用，我们在日常工作中难免会“踩到雷区”\nDocker Engine 则和 Docker Desktop 正好相反，完全免费，但只能在 Linux 上运行，只能使用命令行操作，缺乏辅助工具，需要我们自己动手 DIY 运行环境。不过要是较起真来，它才是 Docker 当初的真正形态，“血脉”最纯正，也是现在各个公司在生产环境中实际使用的 Docker 产品，毕竟机房里 99% 的服务器跑的都是 Linux\n2 Docker的安装     Docker 支持以下的 64 位 CentOS 版本\n CentOS 7 CentOS 8 更高版本\u0026hellip;  可以使用官方脚本自动安装，也可以手动安装\n2.1 手动安装     较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，需要卸载它们以及相关的依赖项\n$ yum remove docker \\  docker-client \\  docker-client-latest \\  docker-common \\  docker-latest \\  docker-latest-logrotate \\  docker-logrotate \\  docker-engine 安装 Docker Engine-Community,使用 Docker 仓库进行安装，在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker\n1.设置仓库\n安装所需的软件包。yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2\n$ yum install -y yum-utils \\  device-mapper-persistent-data \\  lvm2 使用以下命令来设置稳定的仓库\n官方源地址\n$ yum-config-manager \\  --add-repo \\  https://download.docker.com/linux/centos/docker-ce.repo 国内源地址，阿里云\n$ yum-config-manager \\  --add-repo \\  http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 2.安装Docker Engine-Community\n安装最新版本的 Docker Engine-Community 和 containerd，或者转到下一步安装特定版本\n$ yum install docker-ce docker-ce-cli containerd.io 要安装特定版本的 Docker Engine-Community，要在存储库中列出可用版本，然后选择并安装\n1.列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。\n$ yum list docker-ce --showduplicates | sort -r docker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stable docker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stable docker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stable docker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable 该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1\n$ yum install docker-ce-\u0026lt;VERSION_STRING\u0026gt; docker-ce-cli-\u0026lt;VERSION_STRING\u0026gt; containerd.io 2.2 自动安装     使用官方安装脚本自动安装\n$ curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 也可以使用国内 daocloud 一键安装命令\n$ curl -sSL https://get.daocloud.io/docker | sh 2.3 卸载docker     删除安装包\n$ yum remove docker-ce 删除镜像、容器、配置文件等内容\n$ rm -rf /var/lib/docker 3 Docker的简单使用     Docker 安装完默认未启动。并且已经创建好 docker 用户组，但该用户组下没有用户\n操作 Docker 必须要有 root 权限，而直接使用 root 用户不够安全，加入 Docker 用户组是一个比较好的选择，这也是 Docker 官方推荐的做法，当然，如果只是为了图省事，你也可以直接切换到 root 用户来操作 Docker\n$ usermod -aG docker ${USER} #当前用户加入docker组 启动docker服务\n$ service docker start #启动docker服务 $ systemctl start docker\t#启动docker服务 验证 Docker 是否安装成功了，使用的命令是 docker version 和 docker info\ndocker version 会输出 Docker 客户端和服务器各自的版本信息\n$ docker version Client: Docker Engine - Community Version: 20.10.17 API version: 1.41 Go version: go1.17.11 Git commit: 100c701 Built: Mon Jun 6 23:05:12 2022 OS/Arch: linux/amd64 Context: default Experimental: true Server: Docker Engine - Community Engine: Version: 20.10.17 API version: 1.41 (minimum version 1.12) Go version: go1.17.11 Git commit: a89b842 Built: Mon Jun 6 23:03:33 2022 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.6.6 GitCommit: 10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1 runc: Version: 1.1.2 GitCommit: v1.1.2-0-ga916309 docker-init: Version: 0.19.0 GitCommit: de40ad0 docker info 会显示当前 Docker 系统相关的信息，例如 CPU、内存、容器数量、镜像数量、容器运行时、存储文件系统等等\n$ docker info Server: Containers: 1 Running: 0 Paused: 0 Stopped: 1 Images: 8 Server Version: 20.10.12 Storage Driver: overlay2 Backing Filesystem: extfs Cgroup Driver: systemd Default Runtime: runc Kernel Version: 5.13.0-19-generic Operating System: Ubuntu Jammy Jellyfish (development branch) OSType: linux Architecture: aarch64 CPUs: 2 Total Memory: 3.822GiB Docker Root Dir: /var/lib/docker docker info 显示的这些信息，对于我们了解 Docker 的内部运行状态非常有用，比如在这里，你就能够看到当前有一个容器处于停止状态，有 8 个镜像，存储用的文件系统是 overlay2，Linux 内核是 5.13，操作系统是 Ubuntu 22.04 Jammy Jellyfish，硬件是 aarch64，两个 CPU，内存 4G\ndocker ps，它会列出当前系统里运行的容器，就像我们在 Linux 系统里使用 ps 命令列出运行的进程一样（所有的 Docker 操作都是这种形式：以 docker 开始，然后是一个具体的子命令）\n$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES docker pull 是从外部的镜像仓库（Registry）拉取一个 busybox 镜像（image），可以把它类比成是 Ubuntu 里的apt install下载软件包\n$ docker pull busybox docker images它会列出当前 Docker 所存储的所有镜像\n$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest 7a80323521cc 4 days ago 1.24MB hello-world latest feb5d9fea6a5 10 months ago 13.3kB 从busybox镜像启动容器，执行 echo 输出字符串\n$ docker run busybox echo hello world hello world 用 docker ps 命令，加上一个参数 -a ，就可以看到这个已经运行完毕的容器\n$ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 773c267eeccb busybox \u0026#34;echo hello world\u0026#34; 44 seconds ago Exited (0) 43 seconds ago crazy_faraday 8fdc5c075781 hello-world \u0026#34;/hello\u0026#34; 50 minutes ago Exited (0) 50 4 Docker的架构     这张图来自 Docker 官网（https://docs.docker.com/get-started/overview/），精准地描述了 Docker Engine 的内部角色和工作流程\n命令行 docker 实际上是一个客户端 client ，它会与 Docker Engine 里的后台服务 Docker daemon 通信，而镜像则存储在远端的仓库 Registry 里，客户端并不能直接访问镜像仓库\nDocker client 可以通过 build、pull、run等命令向 Docker daemon 发送请求，而 Docker daemon 则是容器和镜像的“大管家”，负责从远端拉取镜像、在本地存储镜像，还有从镜像生成容器、管理容器等所有功能\n所以，在 Docker Engine 里，真正干活的其实是默默运行在后台的 Docker daemon，而我们实际操作的命令行工具“docker”只是个“传声筒”的角色\n补充内容：Kubernetes的知识地图\n"},{"id":25,"href":"/golang/","title":"Golang","parent":"Welcome to Bear2's Secret Garden 💬🐻💬","content":"The Go programming language is an open source project to make programmers more productive.\nGo is expressive, concise, clean, and efficient. Its concurrency mechanisms make it easy to write programs that get the most out of multicore and networked machines, while its novel type system enables flexible and modular program construction. Go compiles quickly to machine code yet has the convenience of garbage collection and the power of run-time reflection. It\u0026rsquo;s a fast, statically typed, compiled language that feels like a dynamically typed, interpreted language.\n"},{"id":26,"href":"/python/1.foreword/","title":"1.foreword","parent":"Python","content":""},{"id":27,"href":"/python/","title":"Python","parent":"Welcome to Bear2's Secret Garden 💬🐻💬","content":"Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming. Python’s elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on most platforms.\nThe Python interpreter and the extensive standard library are freely available in source or binary form for all major platforms from the Python web site, https://www.python.org/, and may be freely distributed. The same site also contains distributions of and pointers to many free third party Python modules, programs and tools, and additional documentation.\nThe Python interpreter is easily extended with new functions and data types implemented in C or C++ (or other languages callable from C). Python is also suitable as an extension language for customizable applications.\n"},{"id":28,"href":"/frontpage/1.toc/","title":"1.目录","parent":"Frontpage","content":"生成页面目录toc\n用法:\n{{\u0026lt; toc \u0026gt;}}例子:\n   标题 1 标题 2  标题 2.1  标题 2.1.1  标题 2.1.1.1     标题 2.2        标题 1     HelloWrold\n标题 2     HelloWrold\n标题 2.1     HelloWrold\n标题 2.1.1     HelloWrold\n标题 2.1.1.1     HelloWrold\n标题 2.2     HelloWrold\n"},{"id":29,"href":"/tags/","title":"Tags","parent":"Welcome to Bear2's Secret Garden 💬🐻💬","content":""}]